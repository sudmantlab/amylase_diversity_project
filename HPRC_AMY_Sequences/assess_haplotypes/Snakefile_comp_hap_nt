#!vim set syntax=vim

import pandas as pd
import pdb
import itertools
import numpy as np
from fasta_reader import read_fasta
from fasta_reader import write_fasta

fetch_bundles = [0,1] 

rule all:
    input:
        "output/haplotype_nt_dists.paf" 



def get_bundle_inputs(w):
    fn ="../AMY_graphs/AMY1A_region_principal_bundles.bed" 
    t = pd.read_csv(fn, names=["name","start","end","binf"], header=None,sep="\t")
    exclude = ["HG01358#2#JAGYZA010000086.1_556_316498_0",
               "HG01928#1#JAGYVQ010000195.1_211_358290_0"]
    inputs = []
    for i, row in t.iterrows():
        contig_name = row['name']
        if contig_name in exclude:
            continue
        for b in fetch_bundles:
            outid ="{c}_{bid}".format(c=contig_name, bid=b)
            inputs.append("output/bundle_seqs/{outid}.fa".format(outid=outid))
    #return ["output/bundle_seqs/HG01361#1#JAGYYX010000012.1_51565085_51878780_0_1.fa"]
    return inputs

def get_paf_inputs(w):
    fn ="../AMY_graphs/AMY1A_region_principal_bundles.bed" 
    t = pd.read_csv(fn, names=["name","start","end","binf"], header=None,sep="\t")
    exclude = ["HG01358#2#JAGYZA010000086.1_556_316498_0",
               "HG01928#1#JAGYVQ010000195.1_211_358290_0"]
    inputs = []
    contigs = []
    for i, row in t.iterrows():
        contig_name = row['name']
        if contig_name in exclude:
            continue
        contigs.append(contig_name)

    for i,c1 in enumerate(contigs):
        for j,c2 in enumerate(contigs):
            for b in fetch_bundles:
                outid ="{c}_{bid}".format(c=contig_name, bid=b)
                inputs.append("output/bundle_alns/{contig_1}:{contig_2}:{bid}.paf".format(contig_1=c1,contig_2=c2,bid=b))
    return inputs

rule make_final_paf:
    input:
        get_paf_inputs
    output:
        "output/haplotype_nt_dists.paf" 
    shell:
        #"cat output/bundle_alns/* > {output[0]}"
        "find ./output/bundle_alns -exec cat {} + >{output[0]]}"

rule do_stuff:
    input:
        "output/bundle_seqs/{contig_1}_{bid}.fa",
        "output/bundle_seqs/{contig_2}_{bid}.fa"
    output:
        "output/bundle_alns/{contig_1}:{contig_2}:{bid}.paf"
    shell:
        "minimap2 -c {input[0]} {input[1]} >{output}"


rule get_bundle_seqs:
    input:
        "../AMY1A_region_seq.fa.gz",
        "../AMY_graphs/AMY1A_region_principal_bundles.bed"
    output:
        "output/bundle_seqs/{contig}_{bid}.fa"
    run:
        seqs_by_id = {}
        for item in read_fasta("../AMY1A_region_seq.fa.gz"):
            id = item.defline
            seq = item.sequence
            seqs_by_id[id] = seq
        
        t = pd.read_csv(input[1], names=["name","start","end","binf"], header=None,sep="\t")
        
        #print(wildcards.contig)
        #contigs = [r['name'] for i, r in t.iterrows()]
        #pdb.set_trace()
        seq_by_contig_bid = {}
        for i, row in t.iterrows():
            contig_name = row['name']
            if not contig_name in seq_by_contig_bid:
                seq_by_contig_bid[contig_name] = {}

            #if contig_name != wildcards.contig:
            #    continue
            if len(contig_name.split("_"))==5:
                ig, cid, contig_s, contig_e, contig = contig_name.split("_")
            else:
                cid, contig_s, contig_e, contig = contig_name.split("_")

            bundle_s, bundle_e = row['start'], row['end']
            contig_s, contig_e = int(contig_s), int(contig_e)
            curr_bundle = int(row['binf'].split(":")[0])
            curr_seq = seqs_by_id[row['name']]

            #if int(curr_bundle) == int(wildcards.bid):
            adj_s = bundle_s - contig_s
            adj_e = bundle_e - contig_s
           
            extract_seq = curr_seq[adj_s:adj_e]
            seq_by_contig_bid[contig_name][curr_bundle] = extract_seq
        outid ="{c}_{bid}".format(c=wildcards.contig, bid=wildcards.bid)
        #with write_fasta("output/bundle_seqs/{outid}.fa".format(outid=outid)) as file:
        seq = seq_by_contig_bid[wildcards.contig][int(wildcards.bid)]
        with write_fasta(output[0]) as file:
            file.write_item(outid, seq)

